// app/dashboard/engine/focus/page.tsx
// ADD THIS TO YOUR EXISTING FOCUS PAGE

// 1. Add import at the top:
import QualityRatingModal from '@/components/focus/QualityRatingModal';

// 2. Add state variables with your other useState declarations:
const [showQualityModal, setShowQualityModal] = useState(false);
const [pendingSessionEnd, setPendingSessionEnd] = useState<{
  sessionId: string;
  elapsedSeconds: number;
  revenue: number;
  notes: string;
} | null>(null);

// 3. REPLACE your existing stopSession function with this:
const stopSession = async () => {
  if (!currentSessionId) return;
  
  const revenueEarned = (elapsedSeconds / 3600) * hourlyRate;

  // Store session data and show quality modal
  setPendingSessionEnd({
    sessionId: currentSessionId,
    elapsedSeconds: elapsedSeconds,
    revenue: revenueEarned,
    notes: notes,
  });
  setShowQualityModal(true);
};

// 4. ADD this new function after stopSession:
const handleQualityRating = async (rating: number) => {
  if (!pendingSessionEnd) return;

  try {
    // If in Pomodoro mode and currently working, save the current work interval
    if (timerMode === 'pomodoro' && pomodoroPhase === 'work' && currentIntervalStart) {
      const newWorkInterval: WorkInterval = {
        start: currentIntervalStart,
        end: new Date().toISOString(),
        duration: currentPhaseSeconds,
      };
      const finalWorkIntervals = [...workIntervals, newWorkInterval];

      const netWorkDuration = calculateNetWorkDuration(finalWorkIntervals, breakIntervals);
      const revenueEarned = (netWorkDuration / 3600) * hourlyRate;

      await supabase
        .from('focus_sessions')
        .update({
          end_time: new Date().toISOString(),
          duration: pendingSessionEnd.elapsedSeconds,
          net_work_duration: netWorkDuration,
          revenue: revenueEarned,
          notes: pendingSessionEnd.notes || null,
          work_intervals: finalWorkIntervals,
          break_intervals: breakIntervals,
          quality_rating: rating, // ✅ ADD QUALITY RATING
        })
        .eq('id', pendingSessionEnd.sessionId);
    } else {
      // Simple mode
      await supabase
        .from('focus_sessions')
        .update({
          end_time: new Date().toISOString(),
          duration: pendingSessionEnd.elapsedSeconds,
          revenue: pendingSessionEnd.revenue,
          notes: pendingSessionEnd.notes || null,
          quality_rating: rating, // ✅ ADD QUALITY RATING
        })
        .eq('id', pendingSessionEnd.sessionId);
    }

    // Reset state
    setShowQualityModal(false);
    setPendingSessionEnd(null);
    setIsRunning(false);
    setCurrentSessionId(null);
    setElapsedSeconds(0);
    setNotes('');
    setTargetDuration(null);
    setPomodoroPhase('work');
    setCurrentPhaseSeconds(0);
    setCompletedIntervals(0);
    setWorkIntervals([]);
    setBreakIntervals([]);
    setCurrentIntervalStart(null);
    
    await loadData();
  } catch (error) {
    console.error('Failed to save quality rating:', error);
  }
};

// 5. REPLACE your existing stopSession function if it's different
// The key changes are:
// - Instead of immediately updating the database, it stores the data
// - Shows the quality modal
// - The actual database update happens in handleQualityRating

// 6. ADD the modal at the end of your JSX, before the closing </div>:
{/* Quality Rating Modal */}
<QualityRatingModal
  isOpen={showQualityModal}
  onClose={() => {
    setShowQualityModal(false);
    setPendingSessionEnd(null);
  }}
  onSubmit={handleQualityRating}
/>

/* 
SUMMARY OF CHANGES:
1. Import QualityRatingModal
2. Add showQualityModal and pendingSessionEnd state
3. Modify stopSession to show modal instead of immediately saving
4. Add handleQualityRating to save with quality rating
5. Add QualityRatingModal component to JSX

This ensures every session completion prompts for quality rating!
*/
